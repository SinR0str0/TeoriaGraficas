<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Graficar Relaciones con Bucles Mejorados</title>
<style>
  #canvas {
    border: 1px solid #ccc;
    background-color: #f9f9f9;
  }
</style>
</head>
<body>

<canvas id="canvas" width="700" height="500"></canvas>

<script>
// Relaciones es un array de objetos, cada uno con propiedades:
// from, to, type (1 = línea sin cabeza, otro número = línea con flecha)
const relaciones = [
  { from: 'A', to: 'B', type: 2 },
  { from: 'A', to: 'C', type: 2 },
  { from: 'B', to: 'D', type: 1 },
  { from: 'C', to: 'D', type: 2 },
  { from: 'D', to: 'E', type: 2 },
  { from: 'E', to: 'A', type: 1 },
  { from: 'A', to: 'B', type: 1 },  // Paralela a la primera A->B pero tipo 1 (sin cabeza)
  { from: 'B', to: 'B', type: 2 },  // Bucle en B
  { from: 'F', to: 'F', type: 2 }   // Vértice desconectado con bucle
];

// Todos los nodos posibles, incluyendo desconectados (los que no están en relaciones)
const verticesDesconectados = ['G']; // Ejemplo nodo desconectado sin aristas

function graficarRelaciones(canvasId, relaciones, vertsDesconectados=[]) {
  const canvas = document.getElementById(canvasId);
  if (!canvas.getContext) {
    alert("Tu navegador no soporta Canvas");
    return;
  }
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Extraer nodos únicos de relaciones y agregar desconectados
  const nodosSet = new Set();
  relaciones.forEach(rel => {
    nodosSet.add(rel.from);
    nodosSet.add(rel.to);
  });
  vertsDesconectados.forEach(v => nodosSet.add(v));
  const nodos = Array.from(nodosSet).sort();

  // Posicionar nodos en círculo
  const centroX = canvas.width / 2;
  const centroY = canvas.height / 2;
  const radio = Math.min(centroX, centroY) - 80;

  const posiciones = {};
  const anguloPaso = (2 * Math.PI) / nodos.length;

  nodos.forEach((nodo, i) => {
    const angulo = i * anguloPaso - Math.PI / 2;
    posiciones[nodo] = {
      x: centroX + radio * Math.cos(angulo),
      y: centroY + radio * Math.sin(angulo)
    };
  });

  // Función para dibujar flecha
  function dibujarFlecha(ctx, fromX, fromY, toX, toY) {
    const headlen = 10;
    const dx = toX - fromX;
    const dy = toY - fromY;
    const angle = Math.atan2(dy, dx);

    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.stroke();

    // Cabeza flecha
    ctx.beginPath();
    ctx.moveTo(toX, toY);
    ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
    ctx.lineTo(toX, toY);
    ctx.fill();
  }

  // Dibuja una línea paralela desplazando por "offset" perpendicularmente
  function dibujarLineaParalela(ctx, x1, y1, x2, y2, offset) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if(dist === 0) return null; // evitar división por cero

    // Vector perpendicular unitario
    const ux = -dy / dist;
    const uy = dx / dist;

    const nx1 = x1 + ux * offset;
    const ny1 = y1 + uy * offset;
    const nx2 = x2 + ux * offset;
    const ny2 = y2 + uy * offset;

    ctx.moveTo(nx1, ny1);
    ctx.lineTo(nx2, ny2);
    return { startX: nx1, startY: ny1, endX: nx2, endY: ny2 };
  }

  // Dibuja bucle en un nodo en forma de arco ajustado
  function dibujarBucle(ctx, x, y, radio=20, type=2) {
    ctx.beginPath();
    const startAngle = Math.PI * 0.3;
    const endAngle = Math.PI * 2.3;
    // Círculo del bucle ligeramente desplazado arriba a la derecha
    ctx.arc(x + radio * 0.7, y - radio * 0.7, radio, startAngle, endAngle);
    ctx.stroke();

    if (type !== 1) {
      // Dibuja cabeza flecha en el punto correspondiente al endAngle
      const angle = endAngle;
      const headlen = 10;
      const arrowX = x + radio * 0.7 + radio * Math.cos(angle);
      const arrowY = y - radio * 0.7 + radio * Math.sin(angle);
      ctx.beginPath();
      ctx.moveTo(arrowX, arrowY);
      ctx.lineTo(arrowX - headlen * Math.cos(angle - Math.PI / 6), arrowY - headlen * Math.sin(angle - Math.PI / 6));
      ctx.lineTo(arrowX - headlen * Math.cos(angle + Math.PI / 6), arrowY - headlen * Math.sin(angle + Math.PI / 6));
      ctx.lineTo(arrowX, arrowY);
      ctx.fill();
    }
  }

  ctx.lineWidth = 2;
  ctx.strokeStyle = '#000';
  ctx.fillStyle = '#000';
  ctx.font = '16px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Preparar datos para detectar líneas paralelas entre mismos nodos
  const mapaParejas = {};
  relaciones.forEach((rel, idx) => {
    // Clave ordenada para la pareja (from,to)
    let key = rel.from < rel.to ? rel.from + '-' + rel.to : rel.to + '-' + rel.from;
    if (!mapaParejas[key]) mapaParejas[key] = [];
    mapaParejas[key].push(idx);
  });

  // Dibujar aristas
  relaciones.forEach((rel, idx) => {
    const from = rel.from;
    const to = rel.to;
    const tipo = rel.type || 2;
    const pFrom = posiciones[from];
    const pTo = posiciones[to];

    if (!pFrom || !pTo) return;

    ctx.beginPath();

    if (from === to) {
      // Bucle en nodo
      dibujarBucle(ctx, pFrom.x, pFrom.y, 20, tipo);
    } else {
      // Líneas paralelas: offset según posición en grupo
      let key = from < to ? from + '-' + to : to + '-' + from;
      let indicesGrupo = mapaParejas[key];
      let idxEnGrupo = indicesGrupo.indexOf(idx);
      const separacionOffset = 8;
      const mitad = (indicesGrupo.length - 1) / 2;
      const offset = (idxEnGrupo - mitad) * separacionOffset;

      const puntos = dibujarLineaParalela(ctx, pFrom.x, pFrom.y, pTo.x, pTo.y, offset);
      if (!puntos) return;

      if (tipo === 1) {
        ctx.stroke();
      } else {
        ctx.stroke();
        dibujarFlecha(ctx, puntos.startX, puntos.startY, puntos.endX, puntos.endY);
      }
    }
  });

  // Dibujar nodos
  ctx.fillStyle = '#3498db';
  ctx.strokeStyle = '#2980b9';
  ctx.lineWidth = 3;

  nodos.forEach(nodo => {
    const p = posiciones[nodo];
    ctx.beginPath();
    ctx.arc(p.x, p.y, 20, 0, 2 * Math.PI);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = '#fff';
    ctx.fillText(nodo, p.x, p.y);
    ctx.fillStyle = '#3498db';
  });
}

graficarRelaciones('canvas', relaciones, verticesDesconectados);

</script>

</body>
</html>